<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="src/three.js"></script>

    <script>

			var camera, scene, renderer;
			var mesh;

			init();
			animate();

			function init() {

                // TODO : Put these in another file...
			    // SELF - NUMBER OF ELEMENTS IN ARRAY [] : Array.length
			    // SELF - NUMBER OF ELEMENTS IN SET      : Set.length
			    //      - NUMBER OF ELEMENTS IN DICT  {} : Object.keys(dict).length
			    ////////////////////////////////////////////////////////////////////////////////

			    class Node {
			        constructor(id) {
			            this.Id = id;
			            this.Neighbors = new Set();
			            this.Position = new THREE.Vector3(0,0,0);
			            // Future : Edges?
			        }

			        SetPosition(position) {
			            this.Position = position;
			        }

			        AddNeighbor(neighborNode) {
			            if (this.Neighbors.has(neighborNode.Id))
			                return;
			            this.Neighbors.add(neighborNode.Id);
			            neighborNode.AddNeighbor(this);
			        }

			        GetNeighbors() {
			            return this.Neighbors;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class Graph {
			        constructor() {
			            this.Nodes = {};
			            this.NodeIdCounter = 0;
			        }

			        AddNode(node) {
			            if (this.Nodes[node.Id] != null)
			                console.log("Error adding node to graph. Duplicate Ids found.");
			            this.Nodes[node.Id] = node;
			        }

			        RemoveNode(node) {
			            // Dunno if this is fine or not
			            this.Nodes[node.Id] = null;
			        }

			        GetNode(nodeId) {
			            if (this.Nodes[nodeId] == null)
			                console.log('Returning null node for id ' + nodeId);
			            return this.Nodes[nodeId];
			        }

			        GetUniqueNodeId() {
			            return this.NodeIdCounter++;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class AlignedBoundingBox {
			        constructor() {
			            this.Min = new THREE.Vector3(0, 0, 0);
			            this.Max = new THREE.Vector3(0, 0, 0);
			            this.Initialized = false;
			        }

                    // Inclusive of bounds
			        Contains(position) {
			            return ((this.Min.x <= position.x && this.Max.x >= position.x) &&
                            (this.Min.y <= position.y && this.Max.y >= position.y) &&
                            (this.Min.z <= position.z && this.Max.z >= position.z));
			        }

			        GetExtents() {
                        // This is super lame
			            let tempVec = new THREE.Vector3(0,0,0);
			            tempVec.copy(this.Max);
			            tempVec.sub(this.Min);
			            return tempVec;
			        }

			        GetCenter() {
			            // Also super lame
			            let tempVec = new THREE.Vector3(0, 0, 0);
			            tempVec.copy(this.Max);
			            tempVec.add(this.Min);
			            tempVec.multiplyScalar(0.5);
			            return tempVec;
			        }

			        ExpandToInclude(threeVector3) {
			            if (!this.Initialized) {
			                this.Initialized = true;
			                this.Min.copy(threeVector3);
			                this.Max.copy(threeVector3);
			                return;
			            }

			            this.Max.x = Math.max(this.Max.x, threeVector3.x);
			            this.Max.y = Math.max(this.Max.y, threeVector3.y);
			            this.Max.z = Math.max(this.Max.z, threeVector3.z);
			            this.Min.x = Math.min(this.Min.x, threeVector3.x);
			            this.Min.y = Math.min(this.Min.y, threeVector3.y);
			            this.Min.z = Math.min(this.Min.z, threeVector3.z);
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class BoxNode {
			        constructor() {
			            this.FirstChild = null;
			            this.SecondChild = null;
			            this.Bounds = new AlignedBoundingBox();
			            this.NodeIds = [];
			            this.MaxNodes = 7;
			        }

                    // Returns [id, distance] (null, null if no containment)
			        FindNearestNode(position, graph)
			        {

			            // Leaf node
			            if (!this.FirstChild && !this.SecondChild)
			            {
			                let bestDistance = null;
			                let bestId = null;
			                for (let i = 0; i < this.NodeIds.length; i++)
			                {
			                    let nodePosition = graph.GetNode(this.NodeIds[i]);
			                    let displacement = new THREE.Vector3(nodePosition.x, nodePosition.y, nodePosition.z);
			                    displacement.sub(position);
			                    let distance = displacement.length();
			                    if (!bestDistance || distance < bestDistance)
			                    {
			                        bestDistance = distance;
			                        bestId = this.NodeIds[i];
			                    }
			                }

			                return [bestId, bestDistance];
			            }

			            if (!this.Bounds.Contains(position))
			                return [null, null];

			            let firstIdDistanceArray = this.FirstChild.FindNearestNode(position, graph);
			            let secondIdDistanceArray = this.SecondChild.FindNearestNode(position, graph);

                        // Seems like a lot of cases to check if null and return the smaller
			            if (!firstIdDistanceArray[1] && !secondIdDistanceArray[1])
			                return [null, null];
			            else if (secondIdDistanceArray[1] && !firstIdDistanceArray[1])
			                return secondIdDistanceArray;
			            else if (firstIdDistanceArray[1] && !secondIdDistanceArray[1])
			                return firstIdDistanceArray;
			            else if (firstIdDistanceArray[1] <= secondIdDistanceArray[1])
			                return firstIdDistanceArray;
			            else
			                return secondIdDistanceArray;
			        }

			        AddNode(node)
			        {
                        // TODO : Check that it isn't already present...
			            this.NodeIds.push(node.Id);
			            this.Bounds.ExpandToInclude(node.Position);
			        }

			        Construct(nodeIds, graph)
			        {
			            if (nodeIds.length > this.MaxNodes)
			            {
			                // Split along largest dimension (kinda meh heuristic)
			                let localBox = new AlignedBoundingBox();

			                for (let i = 0; i < nodeIds.length; i++)
			                {
			                    let nodePosition = graph.GetNode(nodeIds[i]).Position;
			                    localBox.ExpandToInclude(nodePosition);
			                }

                            // Find longest extent
			                let splittingAlongX = false;
			                let splittingAlongY = false;
			                let splittingAlongZ = false;
			                let boxExtents = localBox.GetExtents();

			                if (boxExtents.x >= boxExtents.y && boxExtents.x >= boxExtents.z)
			                    splittingAlongX = true;
			                else if (boxExtents.y >= boxExtents.x && boxExtents.y >= boxExtents.z)
			                    splittingAlongY = true;
			                else
			                    splittingAlongZ = true;

			                let firstChildNodes = [];
			                let secondChildNodes = [];

			                for (let i = 0; i < nodeIds.length; i++)
			                {
			                    let nodePosition = graph.GetNode(nodeIds[i]).Position;

                                // 'max' box
			                    if ((splittingAlongX && (nodePosition.x >= localBox.GetCenter().x))
                                    || (splittingAlongY && (nodePosition.y >= localBox.GetCenter().y))
                                    || (splittingAlongZ && (nodePosition.z >= localBox.GetCenter().z)))
			                    {
			                        firstChildNodes.push(nodeIds[i]);
			                    }
                                // 'min' box
			                    else
			                    {
			                        secondChildNodes.push(nodeIds[i]);
			                    }
			                }

			                // Construct child nodes

			                this.FirstChild = new BoxNode();
			                this.FirstChild.Construct(firstChildNodes, graph);

			                this.SecondChild = new BoxNode();
			                this.SecondChild.Construct(secondChildNodes, graph);

			                this.Bounds.ExpandToInclude(this.FirstChild.Bounds.Min);
			                this.Bounds.ExpandToInclude(this.FirstChild.Bounds.Max);
			                this.Bounds.ExpandToInclude(this.SecondChild.Bounds.Min);
			                this.Bounds.ExpandToInclude(this.SecondChild.Bounds.Max);

			                return;
			            }

			            // Leaf node
			            for (let i = 0 ; i < nodeIds.length; i++)
			                this.AddNode(graph.GetNode(nodeIds[i]));
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class SpatialGraph extends Graph {
			        constructor(width, height) {
			            super();
			            this.Bounds = new AlignedBoundingBox();
			            this.Root = new BoxNode(); // Null if tree is dirty
			        }

			        AddNode(node) {
			            super.AddNode(node);
			            this.Bounds.ExpandToInclude(node.Position);
			            this.Root = null;
			        }

                    // returns [node, distance]
			        FindNearestNode(x, y) {
			            console.log("Closest node");
			            if (!this.Root)
			            {
			                this.Root = new BoxNode();
			                let nodeArray = []
			                for (let key in this.Nodes)
			                    nodeArray.push(this.Nodes[key].Id);

			                this.Root.Construct(nodeArray, this);
			            }

			            let bestId_bestDistance = this.Root.FindNearestNode(new THREE.Vector3(x, y, 0), this);
                        
			            return bestId_bestDistance;
			        }

			        Evaluate(x, y, property) {
                        // TODO
			            // Find triangle
                        // Interpolate
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////


				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;

				scene = new THREE.Scene();

				let width = 400;
				let height = 400;
				let widthSegments = 15;
				let heightSegments = 15;

				let deltaWidth = width / widthSegments;
				let deltaHeight = height / heightSegments;

				let geometry = new THREE.PlaneBufferGeometry(width,height,widthSegments,heightSegments);
				let vertices = geometry.attributes.position;
				let indices = geometry.index;

				var graph = new SpatialGraph();

				let percentOffset = 0.55;
				let vertexCount = vertices.count;

				for (let i = 0; i < vertexCount; i++)
				{
				    let xOffset = deltaWidth  * percentOffset * (Math.random()-0.5);
				    let yOffset = deltaHeight * percentOffset * (Math.random()-0.5);
				    vertices.setX(i, vertices.getX(i) + xOffset);
				    vertices.setY(i, vertices.getY(i) + yOffset);

				    let newNode = new Node(graph.GetUniqueNodeId());
				    // Will have to re-architect if we want to move vertices during runtime
                    // (Would require remaking the mesh?)
				    let position = new THREE.Vector3(vertices.getX(i),vertices.getY(i),vertices.getZ(i));
				    newNode.SetPosition(position);
				    graph.AddNode(newNode);
				}

				for (let i = 0; i < indices.count; i+=3)
				{
				    let n1 = graph.GetNode(indices.getX(i));
				    let n2 = graph.GetNode(indices.getX(i+1));
				    let n3 = graph.GetNode(indices.getX(i+2));

				    n1.AddNeighbor(n2);
				    n1.AddNeighbor(n3);
				    n2.AddNeighbor(n3);
				}

				let bestId_bestDistance = graph.FindNearestNode(47.2, 33.1);
				console.log(bestId_bestDistance[1]);

				let myTempBox = new AlignedBoundingBox();
				myTempBox.ExpandToInclude(new THREE.Vector3(1, 2, 3));
				myTempBox.ExpandToInclude(new THREE.Vector3(-1, 2.2, 53));

				geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(vertexCount*3), 3));
				let color = new THREE.Color();
				let colors = geometry.attributes.color;

				for (let i = 0; i < vertexCount; i++) {
				    let numberOfNeighbors = graph.GetNode(i).GetNeighbors().size;
				    if (numberOfNeighbors == 2)
				        color.setRGB(0, 0, 1);
				    else if (numberOfNeighbors == 3)
				        color.setRGB(0, 1, 0);
				    else if (numberOfNeighbors == 4)
				        color.setRGB(1, 0, 1);
				    else if (numberOfNeighbors == 6)
				        color.setRGB(1, 1, 0);
				    colors.setXYZ(i, color.r, color.g, color.b);
				}

				let material = new THREE.MeshBasicMaterial({
				    color: 0xffffff,
				    flatShading: true,
				    vertexColors: THREE.VertexColors,
				});

				let wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xfffff, wireframe: true, transparent: true });

				mesh = new THREE.Mesh(geometry, material);
				let wireframe = new THREE.Mesh(geometry, wireframeMaterial);
				mesh.add(wireframe);

				scene.add(mesh);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}

    </script>

</body>
</html>