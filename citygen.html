<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="src/three.js"></script>

    <script>

			var camera, scene, renderer;
			var mesh;

			init();
			animate();

			function init() {

                // TODO : Put these in another file...

			    ////////////////////////////////////////////////////////////////////////////////

			    class Node {
			        constructor(id) {
			            this.Id = id;
			            this.Neighbors = new Set();
			            // Future : Edges?
			        }

			        SetPosition(position) {
			            this.Position = position;
			        }

			        AddNeighbor(neighborNode) {
			            if (this.Neighbors.has(neighborNode.Id))
			                return;
			            this.Neighbors.add(neighborNode.Id);
			            neighborNode.AddNeighbor(this);
			        }

			        GetNeighbors() {
			            return this.Neighbors;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class Graph {
			        constructor() {
			            this.Nodes = {};
			            this.NodeIdCounter = 0;
			        }

			        AddNode(node) {
			            if (this.Nodes[node.Id] != null)
			                console.log("Error adding node to graph. Duplicate Ids found.");
			            this.Nodes[node.Id] = node;
			        }

			        RemoveNode(node) {
			            // Dunno if this is fine or not
			            this.Nodes[node.Id] = null;
			        }

			        GetNode(nodeId) {
			            if (this.Nodes[nodeId] == null)
			                console.log('Returning null node for id ' + nodeId);
			            return this.Nodes[nodeId];
			        }

			        GetUniqueNodeId() {
			            return this.NodeIdCounter++;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;

				scene = new THREE.Scene();

				let width = 400;
				let height = 400;
				let widthSegments = 15;
				let heightSegments = 15;

				let deltaWidth = width / widthSegments;
				let deltaHeight = height / heightSegments;

				let geometry = new THREE.PlaneBufferGeometry(width,height,widthSegments,heightSegments);
				let vertices = geometry.attributes.position;
				let indices = geometry.index;

				var graph = new Graph();

				let percentOffset = 0.55;
				let vertexCount = vertices.count;

				for (let i = 0; i < vertexCount; i++)
				{
				    let xOffset = deltaWidth  * percentOffset * (Math.random()-0.5);
				    let yOffset = deltaHeight * percentOffset * (Math.random()-0.5);
				    vertices.setX(i, vertices.getX(i) + xOffset);
				    vertices.setY(i, vertices.getY(i) + yOffset);

				    let newNode = new Node(graph.GetUniqueNodeId());
				    // Will have to re-architect if we want to move vertices during runtime
                    // (Would require remaking the mesh?)
				    let position = new THREE.Vector3(vertices.getX(i),vertices.getY(i),vertices.getZ(i));
				    newNode.SetPosition(position);
				    graph.AddNode(newNode);
				}

				for (let i = 0; i < indices.count; i+=3)
				{
				    let n1 = graph.GetNode(indices.getX(i));
				    let n2 = graph.GetNode(indices.getX(i+1));
				    let n3 = graph.GetNode(indices.getX(i+2));

				    n1.AddNeighbor(n2);
				    n1.AddNeighbor(n3);
				    n2.AddNeighbor(n3);
				}

				geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(vertexCount*3), 3));
				let color = new THREE.Color();
				let colors = geometry.attributes.color;

				for (let i = 0; i < vertexCount; i++) {
				    let numberOfNeighbors = graph.GetNode(i).GetNeighbors().size;
				    if (numberOfNeighbors == 2)
				        color.setRGB(0, 0, 1);
				    else if (numberOfNeighbors == 3)
				        color.setRGB(0, 1, 0);
				    else if (numberOfNeighbors == 4)
				        color.setRGB(1, 0, 1);
				    else if (numberOfNeighbors == 6)
				        color.setRGB(1, 1, 0);
				    colors.setXYZ(i, color.r, color.g, color.b);
				}

				let material = new THREE.MeshBasicMaterial({
				    color: 0xffffff,
				    flatShading: true,
				    vertexColors: THREE.VertexColors,
				});

				let wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xfffff, wireframe: true, transparent: true });

				mesh = new THREE.Mesh(geometry, material);
				let wireframe = new THREE.Mesh(geometry, wireframeMaterial);
				mesh.add(wireframe);

				scene.add(mesh);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}

    </script>

</body>
</html>




			<!--if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1800;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 0, 1 );
				scene.add( light );

				// shadow

				var canvas = document.createElement( 'canvas' );
				canvas.width = 128;
				canvas.height = 128;

				var context = canvas.getContext( '2d' );
				var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
				gradient.addColorStop( 0.1, 'rgba(210,210,210,1)' );
				gradient.addColorStop( 1, 'rgba(255,255,255,1)' );

				context.fillStyle = gradient;
				context.fillRect( 0, 0, canvas.width, canvas.height );

				var shadowTexture = new THREE.CanvasTexture( canvas );

				var shadowMaterial = new THREE.MeshBasicMaterial( { map: shadowTexture } );
				var shadowGeo = new THREE.PlaneBufferGeometry( 300, 300, 1, 1 );

				var shadowMesh;

				shadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );
				shadowMesh.position.y = - 250;
				shadowMesh.rotation.x = - Math.PI / 2;
				scene.add( shadowMesh );

				shadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );
				shadowMesh.position.y = - 250;
				shadowMesh.position.x = - 400;
				shadowMesh.rotation.x = - Math.PI / 2;
				scene.add( shadowMesh );

				shadowMesh = new THREE.Mesh( shadowGeo, shadowMaterial );
				shadowMesh.position.y = - 250;
				shadowMesh.position.x = 400;
				shadowMesh.rotation.x = - Math.PI / 2;
				scene.add( shadowMesh );

				var radius = 200;

				var geometry1 = new THREE.IcosahedronBufferGeometry( radius, 1 );

				var count = geometry1.attributes.position.count;
				geometry1.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( count * 3 ), 3 ) );

				var geometry2 = geometry1.clone();
				var geometry3 = geometry1.clone();

				var color = new THREE.Color();
				var positions1 = geometry1.attributes.position;
				var positions2 = geometry2.attributes.position;
				var positions3 = geometry3.attributes.position;
				var colors1 = geometry1.attributes.color;
				var colors2 = geometry2.attributes.color;
				var colors3 = geometry3.attributes.color;

				for ( var i = 0; i < count; i ++ ) {

					color.setHSL( ( positions1.getY( i ) / radius + 1 ) / 2, 1.0, 0.5 );
					colors1.setXYZ( i, color.r, color.g, color.b );

					color.setHSL( 0, ( positions2.getY( i ) / radius + 1 ) / 2, 0.5 );
					colors2.setXYZ( i, color.r, color.g, color.b );

					color.setRGB( 1, 0.8 - ( positions3.getY( i ) / radius + 1 ) / 2, 0 );
					colors3.setXYZ( i, color.r, color.g, color.b );

				}

				var material = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					flatShading: true,
					vertexColors: THREE.VertexColors,
					shininess: 0
				} );

				var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );

				var mesh = new THREE.Mesh( geometry1, material );
				var wireframe = new THREE.Mesh( geometry1, wireframeMaterial );
				mesh.add( wireframe );
				mesh.position.x = - 400;
				mesh.rotation.x = - 1.87;
				scene.add( mesh );

				var mesh = new THREE.Mesh( geometry2, material );
				var wireframe = new THREE.Mesh( geometry2, wireframeMaterial );
				mesh.add( wireframe );
				mesh.position.x = 400;
				scene.add( mesh );

				var mesh = new THREE.Mesh( geometry3, material );
				var wireframe = new THREE.Mesh( geometry3, wireframeMaterial );
				mesh.add( wireframe );
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}-->

