<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="src/three.js"></script>

    <script>

			var camera, scene, renderer;
			var mesh;

			init();
			animate();

			function init() {

                // TODO : Put these in another file...

			    ////////////////////////////////////////////////////////////////////////////////

			    class Node {
			        constructor(id) {
			            this.Id = id;
			            this.Neighbors = new Set();
			            // Future : Edges?
			        }

			        SetPosition(position) {
			            this.Position = position;
			        }

			        AddNeighbor(neighborNode) {
			            if (this.Neighbors.has(neighborNode.Id))
			                return;
			            this.Neighbors.add(neighborNode.Id);
			            neighborNode.AddNeighbor(this);
			        }

			        GetNeighbors() {
			            return this.Neighbors;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class Graph {
			        constructor() {
			            this.Nodes = {};
			            this.NodeIdCounter = 0;
			        }

			        AddNode(node) {
			            if (this.Nodes[node.Id] != null)
			                console.log("Error adding node to graph. Duplicate Ids found.");
			            this.Nodes[node.Id] = node;
			        }

			        RemoveNode(node) {
			            // Dunno if this is fine or not
			            this.Nodes[node.Id] = null;
			        }

			        GetNode(nodeId) {
			            if (this.Nodes[nodeId] == null)
			                console.log('Returning null node for id ' + nodeId);
			            return this.Nodes[nodeId];
			        }

			        GetUniqueNodeId() {
			            return this.NodeIdCounter++;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;

				scene = new THREE.Scene();

				let width = 400;
				let height = 400;
				let widthSegments = 15;
				let heightSegments = 15;

				let deltaWidth = width / widthSegments;
				let deltaHeight = height / heightSegments;

				let geometry = new THREE.PlaneBufferGeometry(width,height,widthSegments,heightSegments);
				let vertices = geometry.attributes.position;
				let indices = geometry.index;

				var graph = new Graph();

				let percentOffset = 0.55;
				let vertexCount = vertices.count;

				for (let i = 0; i < vertexCount; i++)
				{
				    let xOffset = deltaWidth  * percentOffset * (Math.random()-0.5);
				    let yOffset = deltaHeight * percentOffset * (Math.random()-0.5);
				    vertices.setX(i, vertices.getX(i) + xOffset);
				    vertices.setY(i, vertices.getY(i) + yOffset);

				    let newNode = new Node(graph.GetUniqueNodeId());
				    // Will have to re-architect if we want to move vertices during runtime
                    // (Would require remaking the mesh?)
				    let position = new THREE.Vector3(vertices.getX(i),vertices.getY(i),vertices.getZ(i));
				    newNode.SetPosition(position);
				    graph.AddNode(newNode);
				}

				for (let i = 0; i < indices.count; i+=3)
				{
				    let n1 = graph.GetNode(indices.getX(i));
				    let n2 = graph.GetNode(indices.getX(i+1));
				    let n3 = graph.GetNode(indices.getX(i+2));

				    n1.AddNeighbor(n2);
				    n1.AddNeighbor(n3);
				    n2.AddNeighbor(n3);
				}

				geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(vertexCount*3), 3));
				let color = new THREE.Color();
				let colors = geometry.attributes.color;

				for (let i = 0; i < vertexCount; i++) {
				    let numberOfNeighbors = graph.GetNode(i).GetNeighbors().size;
				    if (numberOfNeighbors == 2)
				        color.setRGB(0, 0, 1);
				    else if (numberOfNeighbors == 3)
				        color.setRGB(0, 1, 0);
				    else if (numberOfNeighbors == 4)
				        color.setRGB(1, 0, 1);
				    else if (numberOfNeighbors == 6)
				        color.setRGB(1, 1, 0);
				    colors.setXYZ(i, color.r, color.g, color.b);
				}

				let material = new THREE.MeshBasicMaterial({
				    color: 0xffffff,
				    flatShading: true,
				    vertexColors: THREE.VertexColors,
				});

				let wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xfffff, wireframe: true, transparent: true });

				mesh = new THREE.Mesh(geometry, material);
				let wireframe = new THREE.Mesh(geometry, wireframeMaterial);
				mesh.add(wireframe);

				scene.add(mesh);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}

    </script>

</body>
</html>