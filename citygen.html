<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="src/three.js"></script>

    <script>

			var camera, scene, renderer;
			var mesh;
			var sphereNode = null;
			var sphere;
			var graph;
			var geometry;

			init();
			animate();

			function init() {

                // TODO : Put these in another file...
			    // SELF - NUMBER OF ELEMENTS IN ARRAY [] : Array.length
			    // SELF - NUMBER OF ELEMENTS IN SET      : Set.length
			    //      - NUMBER OF ELEMENTS IN DICT  {} : Object.keys(dict).length
			    ////////////////////////////////////////////////////////////////////////////////

			    class Node {
			        constructor(id) {
			            this.Id = id;
			            this.Neighbors = new Set();
			            this.Position = new THREE.Vector3(0, 0, 0);
			            this.Mass = 0; // kg
			            this.Density = 1; // kg / m^2
			            this.Temperature = 0; // K
			            this.Albedo = 0.8; // Percent light reflected
			            this.HeatCapacity = 400; // J /(kg K)
			        }

			        SetPosition(position) {
			            this.Position = position;
			        }

			        AddNeighbor(neighborNode) {
			            if (this.Neighbors.has(neighborNode.Id))
			                return;
			            this.Neighbors.add(neighborNode.Id);
			            neighborNode.AddNeighbor(this);
			        }

			        GetNeighbors() {
			            return Array.from(this.Neighbors);
			        }

			        GetMutualNeighbors(otherNode) {
			            let otherNeighbors = otherNode.GetNeighbors();
			            return Array.from(this.GetNeighbors()).filter(neighbor => (otherNeighbors.includes(neighbor)));
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class Triangle {
			        constructor(firstNodeId, secondNodeId, thirdNodeId)
			        {
			            this.FirstNodeId = firstNodeId;
			            this.SecondNodeId = secondNodeId;
			            this.ThirdNodeId = thirdNodeId;
			            this.Area = null;
			        }

			        // TODO : Bad, need to use evaluate on the graph
			        // Only makes sense for well-conditioned triangles
			        GetAverageAlbedo(graph) {
			            let triangleAlbedo = 0;
			            triangleAlbedo += graph.GetNode(this.FirstNodeId).Albedo;
			            triangleAlbedo += graph.GetNode(this.SecondNodeId).Albedo;
			            triangleAlbedo += graph.GetNode(this.ThirdNodeId).Albedo;
			            return triangleAlbedo / 3.;
			        }

			        // TODO : Bad, need to use evaluate on the graph
			        // Only makes sense for well-conditioned triangles
			        GetAverageTemperature(graph) {
			            let triangleTemp = 0;
			            triangleTemp += graph.GetNode(this.FirstNodeId).Temperature;
			            triangleTemp += graph.GetNode(this.SecondNodeId).Temperature;
			            triangleTemp += graph.GetNode(this.ThirdNodeId).Temperature;
			            return triangleTemp / 3.;
			        }

			        GetCenter(graph) {
			            let center = graph.GetNode(this.FirstNodeId).Position.clone();
			            center.add(graph.GetNode(this.SecondNodeId).Position);
			            center.add(graph.GetNode(this.ThirdNodeId).Position);
			            center.divideScalar(3.);
			            return center;
			        }

			        GetArea(graph) {
                        // Feels dangerous if this returns a reference
			            if (this.Area)
			                return this.Area;

			            let firstPosition = graph.GetNode(this.FirstNodeId).Position;
			            let secondPosition = graph.GetNode(this.SecondNodeId).Position;
			            let thirdPosition = graph.GetNode(this.ThirdNodeId).Position;
                        // Lame
			            let tempVector = new THREE.Vector3(0, 0, 0);
			            this.Area = 0.5 * tempVector.crossVectors(secondPosition.clone().sub(firstPosition),
                            thirdPosition.clone().sub(firstPosition)).length();
			            return this.Area;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class TriangleCollection {
			        constructor() {
			            this.Triangles = {};
			            this.Count = 0;
			        }

			        AddTriangle(firstId, secondId, thirdId) {
			            let hashVal = this.Hash(firstId, secondId, thirdId);
			            if (hashVal in this.Triangles)
			                return;
			            this.Triangles[hashVal] = new Triangle(firstId, secondId, thirdId);
			            this.Count++;
			        }

			        GetTriangle(firstId, secondId, thirdId) {
			            return this.Triangles[Hash(firstId, secondId, thirdId)];
			        }

			        RemoveTriangle(firstId, secondId, thirdId) {
			            let hashVal = Hash(firstId, secondId, thirdId);
			            if (!(hashVal in this.Triangles))
			                return;
			            this.Triangles[hashVal] = null;
			            this.Count--;
			        }

			        Hash(firstId, secondId, thirdId)
			        {
			            // Could verify none of the ids are the same
                        // This is probably slow
			            let ids = [firstId, secondId, thirdId].sort();
			            const zero = '0';
			            const maxLengthPerId = 10; // sufficient for 2^32 ids
			            let hashString = ids[0].toString().padStart(10, zero);
			            hashString += ids[1].toString().padStart(10, zero);
			            hashString += ids[2].toString().padStart(10, zero);
			            return hashString;
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class Graph {
			        constructor() {
			            this.Nodes = {};
			            this.NodeIdCounter = 0;
			            this.Triangles = new TriangleCollection(); // Different would probably be clearer
			        }

			        AddNode(node) {
			            if (this.Nodes[node.Id] != null)
			                console.log("Error adding node to graph. Duplicate Ids found.");
			            this.Nodes[node.Id] = node;
			        }

			        RemoveNode(node) {
			            // Dunno if this is fine or not
			            this.Nodes[node.Id] = null;
			        }

			        GetNode(nodeId) {
			            if (this.Nodes[nodeId] == null)
			                console.log('Returning null node for id ' + nodeId);
			            return this.Nodes[nodeId];
			        }

			        GetUniqueNodeId() {
			            return this.NodeIdCounter++;
			        }

			        BuildTriangles() {
			            for (let key in this.Nodes)
			            {
			                let node = this.Nodes[key];
			                let neighbors = node.GetNeighbors();
			                for (let neighborIndex in neighbors)
			                {
			                    // Super lame
			                    let neighborId = neighbors[neighborIndex];
			                    let mutualNeighbors = node.GetMutualNeighbors(this.GetNode(neighborId));
			                    for (let mutualNeighborIndex in mutualNeighbors)
			                    {
			                        let mutualNeighborId = mutualNeighbors[mutualNeighborIndex];
                                    // Safe to call with different ordering
			                        this.Triangles.AddTriangle(node.Id, neighborId, mutualNeighborId);
			                    }
			                }
			            }
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class AlignedBoundingBox {
			        constructor() {
			            this.Min = new THREE.Vector3(0, 0, 0);
			            this.Max = new THREE.Vector3(0, 0, 0);
			            this.Initialized = false;
			        }

                    // Inclusive of bounds
			        Contains(position) {
			            return ((this.Min.x <= position.x && this.Max.x >= position.x) &&
                            (this.Min.y <= position.y && this.Max.y >= position.y) &&
                            (this.Min.z <= position.z && this.Max.z >= position.z));
			        }

			        ContainedInBoundingSphere(position) {
                        // Lame
			            let tempVec = new THREE.Vector3(0, 0, 0);
			            tempVec.copy(this.GetCenter());
			            let extents = this.GetExtents();
			            tempVec.sub(position);
			            if (tempVec.length() <= extents.length())
			                return true;
			            return false;
			        }

			        GetExtents() {
                        // This is super lame
			            let tempVec = new THREE.Vector3(0,0,0);
			            tempVec.copy(this.Max);
			            tempVec.sub(this.Min);
			            return tempVec;
			        }

			        GetCenter() {
			            // Also super lame
			            let tempVec = new THREE.Vector3(0, 0, 0);
			            tempVec.copy(this.Max);
			            tempVec.add(this.Min);
			            tempVec.multiplyScalar(0.5);
			            return tempVec;
			        }

			        ExpandToInclude(threeVector3) {
			            if (!this.Initialized) {
			                this.Initialized = true;
			                this.Min.copy(threeVector3);
			                this.Max.copy(threeVector3);
			                return;
			            }

			            this.Max.x = Math.max(this.Max.x, threeVector3.x);
			            this.Max.y = Math.max(this.Max.y, threeVector3.y);
			            this.Max.z = Math.max(this.Max.z, threeVector3.z);
			            this.Min.x = Math.min(this.Min.x, threeVector3.x);
			            this.Min.y = Math.min(this.Min.y, threeVector3.y);
			            this.Min.z = Math.min(this.Min.z, threeVector3.z);
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class BoxNode {
			        constructor() {
			            this.FirstChild = null;
			            this.SecondChild = null;
			            this.Bounds = new AlignedBoundingBox();
			            this.NodeIds = [];
			            this.MaxNodes = 7;
			        }

                    // Shouldn't be called externally
			        GetDistanceInternal(position, graph)
			        {
			            // Leaf node
			            if (!this.FirstChild && !this.SecondChild) {
			                let bestDistance = null;
			                let bestId = null;
			                for (let i = 0; i < this.NodeIds.length; i++) {
			                    let nodePosition = graph.GetNode(this.NodeIds[i]).Position;
                                // Lame
			                    let displacement = new THREE.Vector3(nodePosition.x, nodePosition.y, nodePosition.z);
			                    displacement.sub(position);
			                    let distance = displacement.length();
			                    if (!bestDistance || distance < bestDistance) {
			                        bestDistance = distance;
			                        bestId = this.NodeIds[i];
			                    }
			                }

			                return [bestId, bestDistance];
			            }

			            let firstIdDistanceArray = this.FirstChild.GetDistanceInternal(position, graph);
			            let secondIdDistanceArray = this.SecondChild.GetDistanceInternal(position, graph);

                        // These shouldn't return null
			            if (firstIdDistanceArray[1] <= secondIdDistanceArray[1])
			                return firstIdDistanceArray;
			            else
			                return secondIdDistanceArray;

			        }

                    // Returns [id, distance] (null, null if no containment)
			        FindNearestNode(position, graph)
			        {
			            // Leaf node
			            if (!this.FirstChild && !this.SecondChild)
			            {
			                return this.GetDistanceInternal(position, graph);
			            }

			            if (!this.Bounds.ContainedInBoundingSphere(position))
			                return [null, null];

			            let firstIdDistanceArray = this.FirstChild.FindNearestNode(position, graph);
			            let secondIdDistanceArray = this.SecondChild.FindNearestNode(position, graph);

                        // Seems like a lot of cases to check if null and return the smaller
			            if (!firstIdDistanceArray[1] && !secondIdDistanceArray[1])
			                return this.GetDistanceInternal(position, graph);
			            else if (secondIdDistanceArray[1] && !firstIdDistanceArray[1])
			                return secondIdDistanceArray;
			            else if (firstIdDistanceArray[1] && !secondIdDistanceArray[1])
			                return firstIdDistanceArray;
			            else if (firstIdDistanceArray[1] <= secondIdDistanceArray[1])
			                return firstIdDistanceArray;
			            else
			                return secondIdDistanceArray;
			        }

			        AddNode(node)
			        {
                        // TODO : Check that it isn't already present...
			            this.NodeIds.push(node.Id);
			            this.Bounds.ExpandToInclude(node.Position);
			        }

			        Construct(nodeIds, graph)
			        {
			            if (nodeIds.length > this.MaxNodes)
			            {
			                // Split along largest dimension (kinda meh heuristic)
			                let localBox = new AlignedBoundingBox();

			                for (let i = 0; i < nodeIds.length; i++)
			                {
			                    let nodePosition = graph.GetNode(nodeIds[i]).Position;
			                    localBox.ExpandToInclude(nodePosition);
			                }

                            // Find longest extent
			                let splittingAlongX = false;
			                let splittingAlongY = false;
			                let splittingAlongZ = false;
			                let boxExtents = localBox.GetExtents();

			                if (boxExtents.x >= boxExtents.y && boxExtents.x >= boxExtents.z)
			                    splittingAlongX = true;
			                else if (boxExtents.y >= boxExtents.x && boxExtents.y >= boxExtents.z)
			                    splittingAlongY = true;
			                else
			                    splittingAlongZ = true;

			                let firstChildNodes = [];
			                let secondChildNodes = [];

			                for (let i = 0; i < nodeIds.length; i++)
			                {
			                    let nodePosition = graph.GetNode(nodeIds[i]).Position;

                                // 'max' box
			                    if ((splittingAlongX && (nodePosition.x >= localBox.GetCenter().x))
                                    || (splittingAlongY && (nodePosition.y >= localBox.GetCenter().y))
                                    || (splittingAlongZ && (nodePosition.z >= localBox.GetCenter().z)))
			                    {
			                        firstChildNodes.push(nodeIds[i]);
			                    }
                                // 'min' box
			                    else
			                    {
			                        secondChildNodes.push(nodeIds[i]);
			                    }
			                }

			                // Construct child nodes

			                this.FirstChild = new BoxNode();
			                this.FirstChild.Construct(firstChildNodes, graph);

			                this.SecondChild = new BoxNode();
			                this.SecondChild.Construct(secondChildNodes, graph);

			                this.Bounds.ExpandToInclude(this.FirstChild.Bounds.Min);
			                this.Bounds.ExpandToInclude(this.FirstChild.Bounds.Max);
			                this.Bounds.ExpandToInclude(this.SecondChild.Bounds.Min);
			                this.Bounds.ExpandToInclude(this.SecondChild.Bounds.Max);

			                return;
			            }

			            // Leaf node
			            for (let i = 0 ; i < nodeIds.length; i++)
			                this.AddNode(graph.GetNode(nodeIds[i]));
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////

			    class SpatialGraph extends Graph {
			        constructor(width, height) {
			            super();
			            this.Bounds = new AlignedBoundingBox();
			            this.Root = new BoxNode(); // Null if tree is dirty
			        }

			        AddNode(node) {
			            super.AddNode(node);
			            this.Bounds.ExpandToInclude(node.Position);
			            this.Root = null;
			        }

			        // returns [node, distance]
			        // Not completely sure about this, need to think about it some more.
			        // Seems like it might not get the best distance for some sparse 
                    // point distributions.
			        FindNearestNode(x, y) {
			            console.log("Closest node");
			            if (!this.Root)
			            {
			                this.Root = new BoxNode();
			                let nodeArray = []
			                for (let key in this.Nodes)
			                    nodeArray.push(this.Nodes[key].Id);

			                this.Root.Construct(nodeArray, this);
			            }

			            let bestId_bestDistance = this.Root.FindNearestNode(new THREE.Vector3(x, y, 0), this);
                        
			            return bestId_bestDistance;
			        }

			        Evaluate(x, y, property) {
                        // TODO
			            // If contained in a triangle,
			            // the triangle will be formed by the closest node
                        // and two of its neighbors.
                        // Interpolate barycentric coordinates
			        }
			    }

			    ////////////////////////////////////////////////////////////////////////////////


				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;

				scene = new THREE.Scene();

				let width = 400;
				let height = 400;
				let widthSegments = 15;
				let heightSegments = 15;

				let deltaWidth = width / widthSegments;
				let deltaHeight = height / heightSegments;

				geometry = new THREE.PlaneBufferGeometry(width,height,widthSegments,heightSegments);
				let vertices = geometry.attributes.position;
				let indices = geometry.index;

				graph = new SpatialGraph();

				let percentOffset = 0.55;
				let vertexCount = vertices.count;

				for (let i = 0; i < vertexCount; i++)
				{
				    let xOffset = deltaWidth  * percentOffset * (Math.random()-0.5);
				    let yOffset = deltaHeight * percentOffset * (Math.random()-0.5);
				    vertices.setX(i, vertices.getX(i) + xOffset);
				    vertices.setY(i, vertices.getY(i) + yOffset);

				    let newNode = new Node(graph.GetUniqueNodeId());
				    // Will have to re-architect if we want to move vertices during runtime
                    // (Would require remaking the mesh?)
				    let position = new THREE.Vector3(vertices.getX(i),vertices.getY(i),vertices.getZ(i));
				    newNode.SetPosition(position);
				    graph.AddNode(newNode);
				}

				for (let i = 0; i < indices.count; i+=3)
				{
				    let n1 = graph.GetNode(indices.getX(i));
				    let n2 = graph.GetNode(indices.getX(i+1));
				    let n3 = graph.GetNode(indices.getX(i+2));

				    n1.AddNeighbor(n2);
				    n1.AddNeighbor(n3);
				    n2.AddNeighbor(n3);
				}

				let bestId_bestDistance = graph.FindNearestNode(47.2, 33.1);
				console.log(graph.GetNode(bestId_bestDistance[0]).Position);
				console.log(bestId_bestDistance[1]);

				graph.BuildTriangles();
				console.log(graph.Triangles.Count);

				for (key in graph.Triangles.Triangles)
				{
				    let triangle = graph.Triangles.Triangles[key];
				    let area = triangle.GetArea(graph) / 3.;
				    graph.GetNode(triangle.FirstNodeId).Mass += graph.GetNode(triangle.FirstNodeId).Density * area;
				    graph.GetNode(triangle.SecondNodeId).Mass += graph.GetNode(triangle.SecondNodeId).Density * area;
				    graph.GetNode(triangle.ThirdNodeId).Mass += graph.GetNode(triangle.ThirdNodeId).Density * area;
				}

				geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(vertexCount*3), 3));
				//let color = new THREE.Color();
				//let colors = geometry.attributes.color;

				//let maxMass = null;
				//for (let i = 0; i < vertexCount; i++)
				//{
				//    if (!maxMass || maxMass < graph.GetNode(i).Mass)
				//        maxMass = graph.GetNode(i).Mass;
				//}
				//for (let i = 0; i < vertexCount; i++) {
				//    let nodeMass = graph.GetNode(i).Mass;
				//    let vertexColor = RainbowColor(nodeMass, maxMass);
				//    colors.setXYZ(i, vertexColor[0], vertexColor[1], vertexColor[2]);
				//}

				let material = new THREE.MeshBasicMaterial({
				    color: 0xffffff,
				    flatShading: true,
				    vertexColors: THREE.VertexColors,
				});

				let wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xfffff, wireframe: true, transparent: true });

				mesh = new THREE.Mesh(geometry, material);
				let wireframe = new THREE.Mesh(geometry, wireframeMaterial);
				mesh.add(wireframe);

				let sphereGeometry = new THREE.SphereGeometry( 5, 32, 32 );
				let sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
				sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				let orbitRadius = 150;
				let sphereHeight = 50;
				sphere.translateX(orbitRadius);
				sphere.translateZ(sphereHeight);
				sphereNode = new THREE.Group();
				sphereNode.add(sphere);

				scene.add(mesh);
				scene.add(sphereNode);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			// Update Temperatures
			function UpdateTemperature(graph, sunPosition, sunPower, ambientTemperature) {
			    let heatDictionary = {};
			    for (let nodeId in graph.Nodes)
			        heatDictionary[nodeId] = 0;

			    // Calculate heat per triangle
			    let triangleNormal = new THREE.Vector3(0, 0, 1);
			    let relaxationConstant = 0.01;
			    for (let key in graph.Triangles.Triangles) {
			        let triangle = graph.Triangles.Triangles[key];
			        let triangleCenter = triangle.GetCenter(graph);
			        let triangleArea = triangle.GetArea(graph);
			        let triangleAverageTemp = triangle.GetAverageTemperature(graph);
			        let triangleToSunVector = sunPosition.clone().sub(triangleCenter);
			        // Inverse square
			        let localSunIntensity = sunPower / (4 * Math.PI * triangleToSunVector.lengthSq());
			        let rawHeat = triangleArea * localSunIntensity
			        // Deduct reflected light
			        rawHeat *= (1. - triangle.GetAverageAlbedo(graph));
			        // Deduct due to incident angle (normal area)
			        rawHeat *= triangleNormal.dot(triangleToSunVector);
			        // Loss to ambient temperature (kind of just made this up)
			        let loss = triangleArea * (triangleAverageTemp - ambientTemperature) * relaxationConstant;
			        rawHeat -= loss;
			        heatDictionary[triangle.FirstNodeId] += rawHeat;
			        heatDictionary[triangle.SecondNodeId] += rawHeat;
			        heatDictionary[triangle.ThirdNodeId] += rawHeat;
			    }

			    // Propagate heat between nodes
			    let minEdgeLength = 10; // Guessing, could calculate from graph
			    for (let nodeId in graph.Nodes) {
			        let node = graph.Nodes[nodeId];
			        let neighbors = node.GetNeighbors();

			        for (let neighborIndex in neighbors) {
			            let neighborId = neighbors[neighborIndex];
			            let neighbor = graph.GetNode(neighborId);
			            let distanceBetweenNodes = node.Position.clone().sub(neighbor.Position).length();
			            // Using 1/r for heat propagation ... made it up ... should probably be exponentially decreasing
			            let distanceFactor = minEdgeLength / distanceBetweenNodes;
			            // From node to neighbor
			            // 0.5 because we're going to loop over this pair twice
			            let heatTransfer = 0.5 * distanceFactor * relaxationConstant * (node.Temperature - neighbor.Temperature);
			            heatDictionary[nodeId] -= heatTransfer;
			            heatDictionary[neighborId] += heatTransfer;
			        }
			    }

			    // Update temperatures
			    for (let nodeId in graph.Nodes) {
			        let node = graph.GetNode(nodeId);
			        node.Temperature += heatDictionary[nodeId] / (node.Mass * node.HeatCapacity);
			    }
			}

			// From https://stackoverflow.com/questions/5137831/map-a-range-of-values-e-g-0-255-to-a-range-of-colours-e-g-rainbow-red-b
			// Assumes range [0, maxValue]
			function RainbowColor(value, maxValue) {
			    var i = (value * 255 / maxValue);
			    var r = Math.round(Math.sin(0.024 * i + 0) * 127 + 128);
			    var g = Math.round(Math.sin(0.024 * i + 2) * 127 + 128);
			    var b = Math.round(Math.sin(0.024 * i + 4) * 127 + 128);
			    //console.log([r, g, b]);
			    return new THREE.Color(r / 255., g / 255., b / 255.);
			}

			function animate() {

			    if (sphereNode)
			    {
			        // Update Temperatures
			        let sunPosition = new THREE.Vector3(0, 0, 0);
			        sphere.getWorldPosition(sunPosition);
			        let sunPower = 10000;
			        let ambientTemperature = 100;
			        UpdateTemperature(graph, sunPosition, sunPower, ambientTemperature);

			        // Update Color buffer
			        let maxTemperature = 2 * ambientTemperature;
			        let colors = geometry.attributes.color;
			        for (let nodeId in graph.Nodes)
			        {
			            let nodeTemperature = 10*graph.GetNode(nodeId).Temperature;
			            let vertexColor = RainbowColor(nodeTemperature, maxTemperature);
			            colors.setXYZ(nodeId, vertexColor.r, vertexColor.g, vertexColor.b);
			        }

			        geometry.attributes.color.needsUpdate = true;

			        // Request geometry update
			        sphereNode.rotateZ(0.01);
			    }

				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}

    </script>

</body>
</html>